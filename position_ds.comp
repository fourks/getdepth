#version 430 core

// ワークグループのサイズ
layout(local_size_x = 16, local_size_y = 16) in;

// 入力
layout (binding = 0, r32f) readonly uniform image2D depth;

// イメージのサイズ - 1
const ivec2 ds = imageSize(depth) - 1;

// 出力
layout (binding = 1, rgba32f) writeonly uniform image2D position;

// カメラパラメータ
uniform vec2 dc, df;
uniform vec3 dk;

// 分散
uniform float variance = 0.1;

// フィルタのサイズ
const ivec2 filterSize = ivec2(5, 5);

// フィルタの中心位置
const ivec2 filterOffset = filterSize / 2;

// 一度に処理する領域のサイズ
const ivec2 tileSize = ivec2(gl_WorkGroupSize);

// 近傍を含む領域のサイズ
const ivec2 neighborhoodSize = tileSize + filterOffset * 2;

// 処理する領域の近傍を含めたコピー
shared float pixel[neighborhoodSize.y][neighborhoodSize.x];

// 重み
const float weight[filterSize.y][filterSize.x] =
{
  { 0.018315639, 0.082084999, 0.135335283, 0.082084999, 0.018315639 },
  { 0.082084999, 0.367879441, 0.606530660, 0.367879441, 0.082084999 },
  { 0.135335283, 0.135335283, 1.000000000, 0.606530660, 0.606530660 },
  { 0.082084999, 0.367879441, 0.606530660, 0.367879441, 0.082084999 },
  { 0.018315639, 0.082084999, 0.135335283, 0.082084999, 0.018315639 }
};

// 対象画素の値
float base;

// 重み付き画素値の合計と重みの合計を求める
void f(inout vec2 csum, const in float c, const in float w)
{
  float d = c - base;
  float e = exp(-0.5 * d * d / variance) * w;
  csum += vec2(c * e, e);
}

// インデックスがイメージの領域から外れないようにする
ivec2 clampLocation(ivec2 xy)
{
  return clamp(xy, ivec2(0, 0), ds);
}

// 他のスレッドの共有メモリへのアクセス完了と他のワークグループの処理完了を待つ
void retirePhase()
{
  memoryBarrierShared();
  barrier();
}

void main(void)
{
  // ワークグループが処理する領域の基準位置
  const ivec2 tile_xy = ivec2(gl_WorkGroupID);

  // スレッドが処理する画素のワークグループにおける相対位置
  const ivec2 thread_xy = ivec2(gl_LocalInvocationID);

  // イメージ上の画素位置
  const ivec2 pixel_xy = tile_xy * tileSize + thread_xy;

  // スレッドが処理する画素位置
  const uint x = thread_xy.x;
  const uint y = thread_xy.y;

  // 処理する領域をコピーする
  for (int j = 0; j < neighborhoodSize.y; j += tileSize.y)
  {
    for (int i = 0; i < neighborhoodSize.x; i += tileSize.x)
    {
      if (x + i < neighborhoodSize.x && y + j  < neighborhoodSize.y)
      {
        const ivec2 read_at = clampLocation(pixel_xy + ivec2(i, j) - filterOffset);
        pixel[y + j][x + i] = imageLoad(depth, read_at).r;
      }
    }
  }

  // 他のスレッドの共有メモリへのアクセス完了と他のワークグループの処理完了を待つ
  retirePhase();

  // 対象画素の値を基準値とする
  base = pixel[y + filterOffset.y][x + filterOffset.x];

  // 対象画素の値とその重みのペアを作る
  vec2 csum = vec2(0.0);

  for (int j = 0; j < filterSize.y; ++j)
  {
    for (int i = 0; i < filterSize.x; ++i)
    {
      f(csum, pixel[y + j][x + i], weight[j][i]);
    }
  }

  // デプス値を取り出す
  float z = csum.r / csum.g;

  // 画素のスクリーン座標
  vec2 dp = (pixel_xy - dc + 0.5f) / df;

  // デプスカメラの歪み補正係数
  float dr = dot(dp, dp);
  float dq = (1.0 + dr * (dk.x + dr * (dk.y + dr * dk.z)));

  // デプス値からカメラ座標値を求める
  imageStore(position, pixel_xy, vec4(dp * z / dq, z, 1.0));
}
