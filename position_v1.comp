#version 430 core

// ワークグループのサイズ
layout(local_size_x = 16, local_size_y = 20) in;

// 入力
layout (binding = 0, r32f) readonly uniform image2D depth;

// イメージのサイズ - 1
const ivec2 ds = imageSize(depth) - 1;

// 出力
layout (binding = 1, rgba32f) writeonly uniform image2D position;

// スケール
uniform vec2 scale;

// 分散
uniform float variance = 0.1;

// フィルタのサイズ
const ivec2 filterSize = ivec2(5, 5);

// フィルタの中心位置
const ivec2 filterOffset = filterSize / 2;

// 一度に処理する領域のサイズ
const ivec2 tileSize = ivec2(gl_WorkGroupSize) - ivec2(0, filterOffset.y * 2);

// 近傍を含む領域のサイズ
const ivec2 neighborhoodSize = tileSize + filterOffset * 2;

// 処理する領域の近傍を含めたコピー
shared float pixel[neighborhoodSize.y][neighborhoodSize.x];
shared float row[neighborhoodSize.y][tileSize.x]; 

// 重み
const float rowWeight[filterSize.x] = { 0.135335283, 0.60653066, 1.0, 0.60653066, 0.135335283 };
const float columnWeight[filterSize.y] = { 0.135335283, 0.60653066, 1.0, 0.60653066, 0.135335283 };

// 対象画素の値
float base;

// 重み付き画素値の合計と重みの合計を求める
void f(inout vec2 csum, const in float c, const in float w)
{
  float d = c - base;
  float e = exp(-0.5 * d * d / variance) * w;
  csum += vec2(c * e, e);
}

// インデックスがイメージの領域から外れないようにする
ivec2 clampLocation(ivec2 xy)
{
  return clamp(xy, ivec2(0, 0), ds);
}

// 他のスレッドの共有メモリへのアクセス完了と他のワークグループの処理完了を待つ
void retirePhase()
{
  memoryBarrierShared();
  barrier();
}

void main(void)
{
  // ワークグループが処理する領域の基準位置
  const ivec2 tile_xy = ivec2(gl_WorkGroupID);

  // スレッドが処理する画素のワークグループにおける相対位置
  const ivec2 thread_xy = ivec2(gl_LocalInvocationID);

  // イメージ上の画素位置
  const ivec2 pixel_xy = tile_xy * tileSize + thread_xy - ivec2(0, filterOffset.y);

  // スレッドが処理する画素位置
  const uint x = thread_xy.x;
  const uint y = thread_xy.y;

  // 処理する領域をコピーする
  for (int i = 0; i < neighborhoodSize.x; i += tileSize.x)
  {
    if (x + i < neighborhoodSize.x)
    {
      const ivec2 read_at = clampLocation(pixel_xy + ivec2(i - filterOffset.x, 0));
      pixel[y][x + i] = imageLoad(depth, read_at).r;
    }
  }

  // 他のスレッドの共有メモリへのアクセス完了と他のワークグループの処理完了を待つ
  retirePhase();

  // 対象画素の値を基準値とする
  base = pixel[y][x + filterOffset.x];

  // 対象画素の値とその重みのペアを作る
  vec2 csum = vec2(0.0);

  for(int i = 0; i < filterSize.x; ++i)
  {
    f(csum, pixel[y][x + i], rowWeight[i]);
  }

  // デプス値を取り出す
  row[y][x] = csum.r / csum.g;

  // 他のスレッドの共有メモリへのアクセス完了と他のワークグループの処理完了を待つ
  retirePhase();

  if (y < tileSize.y)
  {
    // 対象画素の値とその重みのペアを作る
    vec2 csum = vec2(0.0);

    for (int j = 0; j < filterSize.y; ++j)
    {
      f(csum, row[y + j][x], columnWeight[j]);
    }

    // デプス値を取り出す
    float z = csum.r / csum.g;

    // デプス値からカメラ座標値を求める
    imageStore(position, pixel_xy, vec4((vec2(pixel_xy) / vec2(ds) - 0.5) * scale * z, z, 1.0));
  }
}
